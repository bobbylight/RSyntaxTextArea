/**
 * 27/02/2025
 * PowerShellTokenMaker.java - Scanner for the PowerShell scripting language.
 *
 * This library is distributed under a modified BSD license. See the included
 * LICENSE file for details. 
 */
package org.fife.ui.rsyntaxtextarea.modes;

import java.io.*;
import javax.swing.text.Segment;

import org.fife.ui.rsyntaxtextarea.AbstractJFlexTokenMaker;
import org.fife.ui.rsyntaxtextarea.Token;
import org.fife.ui.rsyntaxtextarea.TokenTypes;
import org.fife.ui.rsyntaxtextarea.TokenImpl;

/**
 * Scanner for the PowerShell scripting language.
 *
 * This implementation was created using
 * <a href="https://www.jflex.de/">JFlex</a> 1.4.1; however, the generated file
 * was modified for performance.  Memory allocation needs to be almost
 * completely removed to be competitive with the handwritten lexers (subclasses
 * of <code>AbstractTokenMaker</code>), so this class has been modified so that
 * Strings are never allocated (via yytext()), and the scanner never has to
 * worry about refilling its buffer (needlessly copying chars around).
 * We can achieve this because RText always scans exactly 1 line of tokens at a
 * time, and hands the scanner this line as an array of characters (a Segment
 * really).  Since tokens contain pointers to char arrays instead of Strings
 * holding their contents, there is no need for allocating new memory for
 * Strings.<p>
 *
 * The actual algorithm generated for scanning has, of course, not been
 * modified.<p>
 *
 * If you wish to regenerate this file yourself, keep in mind the following:
 * <ul>
 *   <li>The generated <code>CTokenMaker.java</code> file will contain two
 *       definitions of both <code>zzRefill</code> and <code>yyreset</code>.
 *       You should hand-delete the second of each definition (the ones
 *       generated by the lexer), as these generated methods modify the input
 *       buffer, which we'll never have to do.</li>
 *   <li>You should also change the declaration/definition of zzBuffer to NOT
 *       be initialized.  This is a needless memory allocation for us since we
 *       will be pointing the array somewhere else anyway.</li>
 *   <li>You should NOT call <code>yylex()</code> on the generated scanner
 *       directly; rather, you should use <code>getTokenList</code> as you would
 *       with any other <code>TokenMaker</code> instance.</li>
 * </ul>
 *
 *
 * @author DOUDOU DIAWARA
 * @version 0.0
 */
%%

%public
%class PowerShellTokenMaker
%extends AbstractJFlexTokenMaker
%unicode
%type org.fife.ui.rsyntaxtextarea.Token
%ignorecase

%{
    /**
     * Constructor. This must be here because JFlex does not generate a
     * no-parameter constructor.
     */
    public PowerShellTokenMaker() {
        super();
    }

    /**
     * Adds the token specified to the current linked list of tokens.
     *
     * @param tokenType The token's type.
     */
    private void addToken(int tokenType) {
        addToken(zzStartRead, zzMarkedPos-1, tokenType);
    }

    /**
     * Adds the token specified to the current linked list of tokens.
     *
     * @param tokenType The token's type.
     */
    private void addToken(int start, int end, int tokenType) {
        int so = start + offsetShift;
        addToken(zzBuffer, start, end, tokenType, so);
    }

    /**
     * Adds the token specified to the current linked list of tokens.
     *
     * @param array The character array.
     * @param start The starting offset in the array.
     * @param end The ending offset in the array.
     * @param tokenType The token's type.
     * @param startOffset The offset in the document at which this token
     *                    occurs.
     */
    @Override
    public void addToken(char[] array, int start, int end, int tokenType, int startOffset) {
        super.addToken(array, start, end, tokenType, startOffset);
        zzStartRead = zzMarkedPos;
    }

    @Override
    public String[] getLineCommentStartAndEnd(int languageIndex) {
        return new String[] { "#", null };
    }

    /**
     * Returns the first token in the linked list of tokens generated
     * from <code>text</code>.  This method must be implemented by
     * subclasses so they can correctly implement syntax highlighting.
     *
     * @param text The text from which to get tokens.
     * @param initialTokenType The token type we should start with.
     * @param startOffset The offset into the document at which
     *        <code>text</code> starts.
     * @return The first <code>Token</code> in a linked list representing
     *         the syntax highlighted text.
     */
    @Override
    public Token getTokenList(Segment text, int initialTokenType, int startOffset) {
        resetTokenList();
        this.offsetShift = -text.offset + startOffset;

        // Start off in the proper state.
        int state = TokenTypes.NULL;
        switch (initialTokenType) {
            case TokenTypes.COMMENT_MULTILINE:
                state = BLOCK_COMMENT;
                break;
            default:
                state = YYINITIAL;
        }

        s = text;
        try {
            yyreset(zzReader);
            yybegin(state);
            return yylex();
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return new TokenImpl();
        }
    }

    /**
     * Refills the input buffer.
     *
     * @return      <code>true</code> if EOF was reached, otherwise
     *              <code>false</code>.
     */
    private boolean zzRefill() {
        return zzCurrentPos>=s.offset+s.count;
    }

    /**
     * Resets the scanner to read from a new input stream.
     * Does not close the old reader.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost).
     * Lexical state is set to <tt>YY_INITIAL</tt>.
     *
     * @param reader   the new input stream
     */
    public final void yyreset(Reader reader) {
        // 's' has been updated.
        zzBuffer = s.array;
        /*
         * We replaced the line below with the two below it because zzRefill
         * no longer "refills" the buffer (since the way we do it, it's always
         * "full" the first time through, since it points to the segment's
         * array).  So, we assign zzEndRead here.
         */
        //zzStartRead = zzEndRead = s.offset;
        zzStartRead = s.offset;
        zzEndRead = zzStartRead + s.count - 1;
        zzCurrentPos = zzMarkedPos = zzPushbackPos = s.offset;
        zzLexicalState = YYINITIAL;
        zzReader = reader;
        zzAtBOL  = true;
        zzAtEOF  = false;
    }
%}

/* Lexical states */
%state BLOCK_COMMENT

LineTerminator = (\n|\r|\r\n)
WhiteSpace = [ \t\f]
Letter = [a-zA-Z]
Digit = [0-9]
Words = [a-zA-Z]+
WordChar = {Letter}|{Digit}|_
Identifier = {Letter}({WordChar})*

/* Strings */
EscapedChar = `[`\"'bfnrt$0]

/* Comments */
LineComment = #.*
BlockCommentStart = <#
BlockCommentEnd = #>

/* Numbers */
HexDigit = [0-9a-fA-F]
HexNumber = 0[xX]{HexDigit}+
DecimalNumber = ([-])?({Digit})+
FloatNumber = ([-])?({Digit})+(\.({Digit})+)?([eE][+-]?({Digit})+)?

/*String literals */
stringliteral           = \"([^\"\n\r])*\"
stringsingle            = \'([^\'\n\r])*\'

%%

<YYINITIAL> {
    /* Keywords */
    "begin" |
    "break" |
    "catch" |
    "class" |
    "continue" |
    "data" |
    "define" |
    "do" |
    "dynamicparam" |
    "else" |
    "elseif" |
    "end" |
    "enum" |
    "exit" |
    "filter" |
    "finally" |
    "for" |
    "foreach" |
    "from" |
    "function" |
    "hidden" |
    "if" |
    "in" |
    "param" |
    "process" |
    "pause" |
    "return" |
    "static" |
    "switch" |
    "throw" |
    "trap" |
    "try" |
    "until" |
    "using" |
    "var" |
    "while" |
     /* Variables(special case not Keywords but need to be highlighted */
    "$true" |
    "$false" |
    "$null" |
    "$_" |
    "$PSItem" |
    "$args" |
    "$input" |
    "$this" |
    "$host" { addToken(TokenTypes.RESERVED_WORD); }

    /* Common cmdlets built-in - "Verb-Noun" */
    /* A: */
    "Add-"{Words} |
    "Assert-"{Words} |
    /* B: */
    "Backup-"{Words} |
    "BackupToAAD-"{Words} |
    "Block-"{Words} |
    /* C: */
    "Checkpoint-"{Words} |
    "Clear-"{Words} |
    "Close-"{Words} |
    "Compare-"{Words} |
    "Complete-"{Words} |
    "Compress-"{Words} |
    "Confirm-"{Words} |
    "Connect-"{Words} |
    "Copy-"{Words} |
    "Convert-"{Words} |
    "ConvertTo-"{Words} |
    "ConvertFrom-"{Words} |
    /* D: */
    "Debug-"{Words} |
    "Delete-"{Words} |
    "Disable-"{Words} |
    "Disconnect-"{Words} |
    "Dismount-"{Words} |
    /* E: */
    "Edit-"{Words} |
    "Enable-"{Words} |
    "Enter-"{Words} |
    "Export-"{Words} |
    "Exit-"{Words} |
    "Expand-"{Words} |
    "Export-"{Words} |
    /* F: */
    "Find-"{Words} |
    "Flush-"{Words} |
    "ForEach-Object" |
    "Format-"{Words} |
    /* G: */
    "Get-"{Words} |
    "Grant-"{Words} |
    /* H: */
    "Hide-VirtualDisk" |
    /* I */
    "Import-"{Words} |
    "Initialize-"{Words} |
    "Install-"{Words} |
    "Invoke-"{Words} |
    /* J: */
    "Join-"{Words} |
    /* K: */
    /* L: */
    "Limit-EventLog" |
    "Lock-BitLocker" |
    /* M: */
    "Measure-"{Words} |
    "Merge-"{Words} |
    "Mount-"{Words} |
    "Move-"{Words} |
    /* N: */
    "New-"{Words} |
    /* O: */
    "Open-"{Words} |
    "Optimize-"{Words} |
    "Out-"{Words} |
    /* P: */
    "Pop-"{Words} |
    "Publish-"{Words} |
    "Push-"{Words} |
    /* Q: */
    /* R: */
    "Read-"{Words} |
    "Receive-"{Words} |
    "Register-"{Words} |
    "Remove-"{Words} |
    "Rename-"{Words} |
    "Repair-"{Words} |
    "Reset-"{Words} |
    "Resize-"{Words} |
    "Resolve-"{Words} |
    "Restart-"{Words} |
    "Restore-"{Words} |
    "Resume-"{Words} |
    "Revoke-"{Words} |
    /* S: */
    "Save-"{Words} |
    "Select-"{Words} |
    "Send-"{Words} |
    "Set-"{Words} |
    "Show-"{Words} |
    "Sort-Object" |
    "Split-"{Words} |
    "Start-"{Words} |
    "Stop-"{Words} |
    "Suspend-"{Words} |
    "Search-"{Words} |
    "Select-"{Words} |
    "Switch-"{Words} |
    "Sync-"{Words} |
    /* T: */
    "Test-"{Words} |
    "Trace-Command" |
    /* U: */
    "Unblock-"{Words} |
    "Undo-"{Words} |
    "Uninstall-"{Words} |
    "Unregister-"{Words} |
    "Update-"{Words} |
    "Use-"{Words} |
    /* V: */
    /* W: */
    "Wait-"{Words} |
    "Where-Object" |
    "Write-"{Words} { addToken(TokenTypes.FUNCTION); }

          /* Identifiers */
    {Identifier} { addToken(TokenTypes.IDENTIFIER); }

    /* Numbers */
    {HexNumber} { addToken(TokenTypes.LITERAL_NUMBER_HEXADECIMAL); }
    {DecimalNumber} { addToken(TokenTypes.LITERAL_NUMBER_DECIMAL_INT); }
    {FloatNumber} { addToken(TokenTypes.LITERAL_NUMBER_FLOAT); }

    /* Operators */
    "=" |
    "+" |
    "-" |
    "*" |
    "/" |
    "%" |
    "+=" |
    "-=" |
    "*=" |
    "/=" |
    "%=" |
    "!" |
    "-not" |
    "-and" |
    "-or" |
    "-xor" |
    "-eq" |
    "-ne" |
    "-gt" |
    "-ge" |
    "-lt" |
    "-le" |
    "-like" |
    "-notlike" |
    "-match" |
    "-notmatch" |
    "-contains" |
    "-notcontains" |
    "-replace" |
    "-split" |
    "-join" |
    /*others any arguments*/
    "-"{Words} |
    "::" |
    "|" { addToken(TokenTypes.OPERATOR); }

    /* Delimiters */
    "(" |
    ")" |
    "[" |
    "]" |
    "{" |
    "}" |
    "," |
    ";" |
    ":" |
    "@" |
    "@(" |
    "@{" |
    "&" { addToken(TokenTypes.SEPARATOR); }
    /*another special that need to highlighted but not Keywords*/
    "$env:" {WordChar}+ { addToken(TokenTypes.RESERVED_WORD_2);  }
    "$global:" {WordChar}+ { addToken(TokenTypes.RESERVED_WORD_2); }
    "$script:" {WordChar}+ { addToken(TokenTypes.RESERVED_WORD_2);  }
    "$local:" {WordChar}+ { addToken(TokenTypes.RESERVED_WORD_2);  }
    "$private:" {WordChar}+ { addToken(TokenTypes.RESERVED_WORD_2); }
    "$PSVersionTable".?{WordChar}* { addToken(TokenTypes.RESERVED_WORD_2); }

    /* Comments */
    {LineComment} { addToken(TokenTypes.COMMENT_EOL); }
    {BlockCommentStart} { yybegin(BLOCK_COMMENT); addToken(TokenTypes.COMMENT_MULTILINE); }

    /* Whitespace */
    {WhiteSpace}+ { addToken(TokenTypes.WHITESPACE); }
    {LineTerminator} { addNullToken(); return firstToken; }

    /* Everything else */
    . { addToken(TokenTypes.ERROR_IDENTIFIER); }

     /* STRING */
      /*String literals */
      {stringliteral} { addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); }
      {stringsingle} { addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); }
}

<BLOCK_COMMENT> {
    {BlockCommentEnd} { yybegin(YYINITIAL); addToken(TokenTypes.COMMENT_MULTILINE); }
    [^#]+ { addToken(TokenTypes.COMMENT_MULTILINE); }
    "#" { addToken(TokenTypes.COMMENT_MULTILINE); }
    {LineTerminator} { addToken(TokenTypes.COMMENT_MULTILINE); }
}


/* Ended with a line not in a string or comment.  */
<<EOF>> { addNullToken(); return firstToken; }
