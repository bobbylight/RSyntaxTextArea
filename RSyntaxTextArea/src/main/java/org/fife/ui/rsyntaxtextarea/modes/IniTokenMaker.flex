/*
 * 11/04/2016
 *
 * IniTokenMaker.java - Scanner for .ini files.
 * 
 * This library is distributed under a modified BSD license.  See the included
 * LICENSE file for details.
 */
package org.fife.ui.rsyntaxtextarea.modes;

import java.io.*;
import javax.swing.text.Segment;

import org.fife.ui.rsyntaxtextarea.*;


/**
 * This class splits up text into tokens representing a .ini file.<p>
 *
 * This implementation was created using
 * <a href="https://www.jflex.de/">JFlex</a> 1.4.1; however, the generated file
 * was modified for performance.  Memory allocation needs to be almost
 * completely removed to be competitive with the handwritten lexers (subclasses
 * of <code>AbstractTokenMaker</code>), so this class has been modified so that
 * Strings are never allocated (via yytext()), and the scanner never has to
 * worry about refilling its buffer (needlessly copying chars around).
 * We can achieve this because RText always scans exactly 1 line of tokens at a
 * time, and hands the scanner this line as an array of characters (a Segment
 * really).  Since tokens contain pointers to char arrays instead of Strings
 * holding their contents, there is no need for allocating new memory for
 * Strings.<p>
 *
 * The actual algorithm generated for scanning has, of course, not been
 * modified.<p>
 *
 * If you wish to regenerate this file yourself, keep in mind the following:
 * <ul>
 *   <li>The generated <code>IniTokenMaker.java</code> file will
 *       contain two definitions of both <code>zzRefill</code> and
 *       <code>yyreset</code>.  You should hand-delete the second of each
 *       definition (the ones generated by the lexer), as these generated
 *       methods modify the input buffer, which we'll never have to do.
 *   <li>You should also change the declaration/definition of zzBuffer to NOT
 *       be initialized.  This is a needless memory allocation for us since we
 *       will be pointing the array somewhere else anyway.
 *   <li>You should NOT call <code>yylex()</code> on the generated scanner
 *       directly; rather, you should use <code>getTokenList</code> as you would
 *       with any other <code>TokenMaker</code> instance.
 * </ul>
 *
 * @author Robert Futrell
 * @version 0.4
 *
 */
%%

%public
%class IniTokenMaker
%extends AbstractJFlexTokenMaker
%unicode
%type org.fife.ui.rsyntaxtextarea.Token


%{


	/**
	 * Constructor.  This must be here because JFlex does not generate a
	 * no-parameter constructor.
	 */
	public IniTokenMaker() {
		super();
	}

	void addToken(int tokenType) {
        super.addToken(s.array, s.offset + zzStartRead, s.offset + zzMarkedPos - 1, tokenType, start + zzStartRead);
    }

    @Override
    public String[] getLineCommentStartAndEnd(int languageIndex) {
        return new String[]{"#", null};
    }

    @Override
    public Token getTokenList(Segment text, int initialTokenType, int startOffset) {
        resetTokenList();

        try {
            super.s = text;
            super.start = startOffset;
            reset(text, 0, text.count, 0);
            yylex();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return firstToken;
    }

    public final String yytext() {
        return zzBuffer.subSequence(zzStartRead, zzMarkedPos).toString();
    }

    @Override
    public void yyclose() throws IOException {
    }

    int idStart = -1;
    int idEnd = -1;

    void updateIdentifier() {
        if (idStart < 0) {
            idStart = zzStartRead;
            idEnd = zzMarkedPos - 1;
        } else {
            idEnd = zzMarkedPos - 1;
        }
    }

    void addIdentifier(int type) {
        if (idStart >= 0) {
            super.addToken(s.array, s.offset + idStart, s.offset + idEnd, type, start + idStart);
            idStart = idEnd = -1;
        }
    }
%}

Equals				= ([=])
Escaped             = "\\"[tnr\"f0;#'\\]
Identifier			= ([^ \t\n#;\[=]*)
Whitespace			= ([ \t]+)
Comment				= ([#;].*)
Section				= ([\[][^\]]*[\]]?)

%state VALUE
%state STRING
%state SINGLE_QUOTE_STRING
%state PRE_VALUE

%%

<YYINITIAL> {
	{Identifier}		{ addToken(Token.DATA_TYPE); }
	{Equals}			{ addToken(Token.OPERATOR); yybegin(PRE_VALUE); }
	{Whitespace}		{ addToken(Token.WHITESPACE); }
	{Comment}			{ addToken(Token.COMMENT_EOL); }
	{Section}			{ addToken(Token.PREPROCESSOR); }
	<<EOF>>				{ addNullToken(); return firstToken; }
}

<PRE_VALUE> {
    {Whitespace}        { addToken(TokenTypes.WHITESPACE); }
    [\"]                { addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); yybegin(STRING); }
    [']                 { addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); yybegin(SINGLE_QUOTE_STRING); }
    [^] 				{ yypushback(1); yybegin(VALUE); }
    <<EOF>>				{ addNullToken(); return firstToken; }
}

<STRING> {
    [\"]                { addIdentifier(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); yybegin(VALUE); }
}

<SINGLE_QUOTE_STRING> {
    [']                 { addIdentifier(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); yybegin(VALUE); }
}

<STRING, SINGLE_QUOTE_STRING> {
    {Escaped}           { addIdentifier(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); addToken(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); }
    {Whitespace}        { addIdentifier(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); addToken(TokenTypes.WHITESPACE); }
    [^]                 { updateIdentifier(); }
    <<EOF>>				{ addIdentifier(TokenTypes.LITERAL_STRING_DOUBLE_QUOTE); addNullToken(); return firstToken; }
}

<VALUE> {
    {Comment}			{ addIdentifier(TokenTypes.IDENTIFIER); addToken(Token.COMMENT_EOL); }
    {Whitespace}        { addIdentifier(TokenTypes.IDENTIFIER); addToken(TokenTypes.WHITESPACE); }
	[^]                 { updateIdentifier(); }
	<<EOF>>				{ addIdentifier(TokenTypes.IDENTIFIER); addNullToken(); return firstToken; }
}
